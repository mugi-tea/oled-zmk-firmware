/*
 * Copyright (c) 2024 The ZMK Contributors
 *
 * SPDX-License-Identifier: MIT
 */

#include <zephyr/kernel.h>

#include <zephyr/logging/log.h>
LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);

#include <zmk/display.h>

#include "bongo_cat.h"

static sys_slist_t widgets = SYS_SLIST_STATIC_INIT(&widgets);

// Image dimensions
#define IMG_WIDTH 50
#define IMG_HEIGHT 26

// Bongo cat bitmap data (1 bit per pixel, 7 bytes per row)
static const uint8_t bongo_cat_both1_data[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x18, 0x7c, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x20, 0x07, 0xc5, 0x00, 0x00,
  0x00, 0x00, 0x40, 0x00, 0x79, 0x00, 0x00,
  0x00, 0x00, 0x80, 0x00, 0x11, 0x00, 0x00,
  0x00, 0x00, 0x80, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x01, 0x08, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x02, 0x14, 0x10, 0x02, 0x00, 0x00,
  0xe0, 0x04, 0x00, 0x28, 0x02, 0x00, 0x00,
  0x1f, 0x08, 0x01, 0x00, 0x01, 0x00, 0x00,
  0x00, 0xf0, 0x03, 0x80, 0x01, 0x80, 0x00,
  0x00, 0x10, 0x20, 0x00, 0x00, 0x80, 0x00,
  0x00, 0x10, 0x7f, 0x82, 0x00, 0x80, 0x00,
  0x00, 0x09, 0x80, 0x7c, 0x00, 0xc0, 0x00,
  0x00, 0x06, 0x00, 0x08, 0x10, 0x40, 0x00,
  0x00, 0x00, 0x00, 0x08, 0x2f, 0xe0, 0x00,
  0x00, 0x00, 0x00, 0x04, 0x40, 0x3e, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x80, 0x01, 0xc0,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// Canvas buffer - L8 format needs 1 byte per pixel
static uint8_t canvas_buf[IMG_WIDTH * IMG_HEIGHT];

static void draw_bongo_cat(lv_obj_t *canvas) {
    // Fill with black first
    memset(canvas_buf, 0x00, sizeof(canvas_buf));

    // Draw white pixels where bitmap has 1s
    for (int y = 0; y < IMG_HEIGHT; y++) {
        for (int x = 0; x < IMG_WIDTH; x++) {
            int byte_idx = y * 7 + (x / 8);
            int bit_idx = 7 - (x % 8);

            if (bongo_cat_both1_data[byte_idx] & (1 << bit_idx)) {
                canvas_buf[y * IMG_WIDTH + x] = 0xFF;
            }
        }
    }

    lv_obj_invalidate(canvas);
}

int zmk_widget_bongo_cat_init(struct zmk_widget_bongo_cat *widget, lv_obj_t *parent) {
    widget->obj = lv_canvas_create(parent);
    lv_canvas_set_buffer(widget->obj, canvas_buf, IMG_WIDTH, IMG_HEIGHT, LV_COLOR_FORMAT_L8);
    lv_obj_center(widget->obj);

    draw_bongo_cat(widget->obj);

    sys_slist_append(&widgets, &widget->node);

    return 0;
}

lv_obj_t *zmk_widget_bongo_cat_obj(struct zmk_widget_bongo_cat *widget) {
    return widget->obj;
}
